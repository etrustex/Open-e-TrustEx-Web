package eu.europa.ec.etrustex.tools.translation;

import eu.europa.ec.etrustex.tools.translation.model.ScreenTranslation;
import eu.europa.ec.etrustex.tools.translation.model.Translation;
import eu.europa.ec.etrustex.tools.translation.service.TranslationService;
import org.apache.log4j.Logger;

import javax.xml.bind.JAXBException;
import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.Arrays;
import java.util.List;

/**
 * Checks the ECI translations for actual usage in the application.
 * <p>
 * Note that this method is not 100% accurate, as it can only look
 * for exact matches on the translation keys in the application files.
 * Especially, if a message is reported as "potentially unused", this
 * means that it can still be actively used in the application, but
 * its usage is too complex to be detected. This applies for instance to
 * programmatic usage (such as error keys generated by Spring reject
 * calls, or fmt:message with JSTL variables in the message keys).
 * </p> 
 *
 * @author keschma
 *
 */
public class TranslationUsageChecker {
	
	private final static Logger LOGGER = Logger.getLogger(TranslationUsageChecker.class);
	
	private final static String CHECK_LANGUAGE_CODE = "en";
	
	private final static String[] PAGE_FILE_SUFFIXES = new String[] { ".jsp", ".jspx", ".properties", ".java" };
	
	private final static String[] REPORT_FILE_SUFFIXES = new String[] { ".jrxml" };
	
	private static MainUtils mainUtils = null; 
	
	public static void main(String[] args) throws Throwable {
		mainUtils = new MainUtils(TranslationUsageChecker.class, args,
				"user=<user> password=<password> host=<host> port=<port> service=<service> roots=DIR1,...DIRn");
		
		// parse root directories
		final String rootDirsArg = mainUtils.getRequiredValue("roots");
		final List<String> rootDirs = mainUtils.parseStringList(rootDirsArg);
		LOGGER.info("Root directories: " + rootDirs);

		// the actual usage checks		
		final TranslationService service = new TranslationService();		
		service.start(mainUtils.getRequiredValue("user"), mainUtils.getRequiredValue("password"),
				"oracle.jdbc.OracleDriver",
				"jdbc:oracle:thin:@" + mainUtils.getRequiredValue("host") + ":" + mainUtils.getRequiredValue("port") + ":" + mainUtils.getRequiredValue("service"));
		
		boolean isSuccess = false;
		try {
			checkScreens(rootDirs, service);
			// note:
			// * reference data translations are used programmatically only
			// (cannot be detected)
			// * mail translations are used in sql files only (hard to detect)
			isSuccess = true;
		} catch (Throwable e) {
			LOGGER.error("An error occurred", e);
			throw e;
		} finally {
			service.stop(isSuccess);
		}
	}

	/**
	 * Checks the screen translations for applicative usage.
	 * @param rootDirs
	 * @param service
	 * @throws JAXBException
	 */
	private static void checkScreens(List<String> rootDirs, TranslationService service) throws Exception {
		LOGGER.info("### Checking screens in " + rootDirs + "; file patterns: " + Arrays.toString(PAGE_FILE_SUFFIXES) + " ###");
		
		final List<Integer> screenIds = service.findAllScreenIds();
		
		for (Integer screenId : screenIds) {
			LOGGER.info("Checking screen: " + screenId);
			
			final List<ScreenTranslation> translations = service.findTranslationsByScreenAndLanguage(screenId, CHECK_LANGUAGE_CODE, false);
			if (!translations.isEmpty()) {
				outer:
				for (Translation translation : translations) {
					for (String rootDir : rootDirs) {
						if (isUsed(translation, Paths.get(rootDir), PAGE_FILE_SUFFIXES)) {
							continue outer;
						}	
					}
					LOGGER.warn("POTENTIALLY UNUSED: " + translation);
				}
			} else {
				LOGGER.info("No screen translations affected.");
			}
		}
	}



	/**
	 * Checks for the actual usage of the given translation in the
	 * application files.
	 * @param translation
	 * @param rootDir
	 * @param fileSuffixes
	 * @return true, if the translation is used
	 */
	private static boolean isUsed(final Translation translation, final Path rootDir,
			final String[] fileSuffixes) throws IOException {

        final IsUsed isUsed = new IsUsed();
        Files.walkFileTree(rootDir, new SimpleFileVisitor<Path>() {

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                final String fileName = file.getFileName().toString();
                FileVisitResult result = FileVisitResult.CONTINUE;

                for (String suffix : fileSuffixes) {
                    if (fileName.endsWith(suffix)) {
                        final String fileContent = new String(Files.readAllBytes(file));
                        if (fileContent.contains(translation.getKey())) {
                            isUsed.used = true;
                            result = FileVisitResult.TERMINATE;
                            break;
                        }
                    }
                }

                return result;
            }
        });

        return isUsed.used;
	}

	private static class IsUsed {
        boolean used = false;
    }

}
